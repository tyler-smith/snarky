// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Field = require("./field.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Elliptic_curve = require("./elliptic_curve.bs.js");

function BabyJubJub(Fq) {
  var size = Curry._1(Field.$$BigInt.ofString, "2736030358979909402780800718157159386076813972158567259200215660948447373041");
  var T = Field.Make0({
        size: size
      });
  var num_bits = function (param) {
    return 251;
  };
  var test_bit = Field.$$BigInt.testBit;
  var to_field = function (t) {
    return t;
  };
  var of_field = function (t) {
    return Curry._1(T.ofBigInt, t);
  };
  var Scalar_size = T.size;
  var Scalar_toString = T.toString;
  var Scalar_add = T.add;
  var Scalar_sub = T.sub;
  var Scalar_mul = T.mul;
  var Scalar_invert = T.invert;
  var Scalar_inv = T.inv;
  var Scalar_equal = T.equal;
  var Scalar_div = T.div;
  var Scalar_$plus = T.$plus;
  var Scalar_$ = T.$neg;
  var Scalar_$star = T.$star;
  var Scalar_$slash = T.$slash;
  var Scalar_one = T.one;
  var Scalar_zero = T.zero;
  var Scalar_negate = T.negate;
  var Scalar_ofString = T.ofString;
  var Scalar_ofInt = T.ofInt;
  var Scalar_ofBits = T.ofBits;
  var Scalar_ofBigInt = T.ofBigInt;
  var Scalar_square = T.square;
  var Scalar_testBit = T.testBit;
  var Scalar_$eq = T.$eq;
  var Scalar = {
    T: T,
    size_in_bits: 251,
    num_bits: num_bits,
    test_bit: test_bit,
    to_field: to_field,
    of_field: of_field,
    size: Scalar_size,
    toString: Scalar_toString,
    add: Scalar_add,
    sub: Scalar_sub,
    mul: Scalar_mul,
    invert: Scalar_invert,
    inv: Scalar_inv,
    equal: Scalar_equal,
    div: Scalar_div,
    $plus: Scalar_$plus,
    $neg: Scalar_$,
    $star: Scalar_$star,
    $slash: Scalar_$slash,
    one: Scalar_one,
    zero: Scalar_zero,
    negate: Scalar_negate,
    ofString: Scalar_ofString,
    ofInt: Scalar_ofInt,
    ofBits: Scalar_ofBits,
    ofBigInt: Scalar_ofBigInt,
    square: Scalar_square,
    testBit: Scalar_testBit,
    $eq: Scalar_$eq
  };
  var a = Curry._1(Fq.ofString, "7296080957279758407415468581752425029516121466805344781232734728849116493472");
  var b = Curry._1(Fq.ofString, "16213513238399463127589930181672055621146936592900766180517188641980520820846");
  var Params = {
    a: a,
    b: b
  };
  var include = Elliptic_curve.Make({
            test_bit: test_bit,
            num_bits: num_bits
          })({
          equal: Fq.equal,
          zero: Fq.zero,
          one: Fq.one,
          inv: Fq.inv,
          $star: Fq.$star,
          square: Fq.square,
          negate: Fq.negate,
          $neg: Fq.$neg,
          $plus: Fq.$plus
        })(Params);
  var of_affine = include.of_affine;
  var to_affine = include.to_affine;
  var $plus = include.$plus;
  var scale = include.scale;
  var map_pr = function (f, param) {
    return /* tuple */[
            Curry._1(f, param[0]),
            Curry._1(f, param[1])
          ];
  };
  var one = Curry._1(of_affine, map_pr(Fq.ofString, /* tuple */[
            "6142832666126200108502958025802235821181485456421382423166796358396261897243",
            "11248300941377020445838278434488928391563663598577146687858078672191633663164"
          ]));
  var toAffine = function (t) {
    var match = Curry._1(to_affine, t);
    if (match !== undefined) {
      return match;
    } else {
      return Pervasives.failwith("toAffine: Identity");
    }
  };
  var scale$1 = function (init, t, s) {
    var p = Curry._2(scale, t, s);
    if (init !== undefined) {
      return Curry._2($plus, p, init);
    } else {
      return p;
    }
  };
  var toJSON = function (param) {
    return {
            x: Curry._1(Fq.toString, param[/* x */0]),
            y: Curry._1(Fq.toString, param[/* y */1]),
            z: Curry._1(Fq.toString, param[/* z */2])
          };
  };
  return {
          Scalar: Scalar,
          Params: Params,
          zero: include.zero,
          Coefficients: include.Coefficients,
          Affine: include.Affine,
          of_affine: of_affine,
          is_zero: include.is_zero,
          to_affine_exn: include.to_affine_exn,
          to_affine: to_affine,
          is_well_formed: include.is_well_formed,
          $plus: $plus,
          $star: include.$star,
          negate: include.negate,
          $neg: include.$neg,
          map_pr: map_pr,
          one: one,
          ofAffine: of_affine,
          toAffine: toAffine,
          scale: scale$1,
          add_exn: $plus,
          toJSON: toJSON
        };
}

var bn128 = /* record */[
  /* a */"7296080957279758407415468581752425029516121466805344781232734728849116493472",
  /* b */"16213513238399463127589930181672055621146936592900766180517188641980520820846",
  /* one : tuple */[
    "6142832666126200108502958025802235821181485456421382423166796358396261897243",
    "11248300941377020445838278434488928391563663598577146687858078672191633663164"
  ]
];

exports.bn128 = bn128;
exports.BabyJubJub = BabyJubJub;
/* Field Not a pure module */
