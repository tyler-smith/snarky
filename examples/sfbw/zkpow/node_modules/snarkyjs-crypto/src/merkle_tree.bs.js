// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

var Tree = { };

function Make(Hash) {
  var Tree = { };
  var hash_tree = function (hash_element, param) {
    if (param.tag) {
      return param[0];
    } else {
      return Curry._1(hash_element, param[0]);
    }
  };
  var root = function (t) {
    return hash_tree(t[/* hash_element */1], t[/* tree */0]);
  };
  var depth = function (t) {
    return t[/* depth */2];
  };
  var merge = function (param, l, r) {
    return Curry._1(Hash.hash, /* array */[
                l,
                r
              ]);
  };
  var ith_bit = function (idx, i) {
    return ((idx >>> i) & 1) === 1;
  };
  var path = function (param, idx) {
    var hash_element = param[/* hash_element */1];
    var go = function (_acc, _i, _tree) {
      while(true) {
        var tree = _tree;
        var i = _i;
        var acc = _acc;
        if (i < 0) {
          return acc;
        } else if (tree.tag) {
          var r = tree[2];
          var l = tree[1];
          var go_right = ith_bit(idx, i);
          if (go_right) {
            _tree = r;
            _i = i - 1 | 0;
            _acc = /* :: */[
              hash_tree(hash_element, l),
              acc
            ];
            continue ;
          } else {
            _tree = l;
            _i = i - 1 | 0;
            _acc = /* :: */[
              hash_tree(hash_element, r),
              acc
            ];
            continue ;
          }
        } else {
          return Pervasives.failwith("Sparse_ledger.path: Bad depth at index");
        }
      };
    };
    return $$Array.of_list(go(/* [] */0, param[/* depth */2] - 1 | 0, param[/* tree */0]));
  };
  var create = function (t, index) {
    return /* record */[
            /* index */index,
            /* path */path(t, index)
          ];
  };
  var implied_root = function (entry_hash, addr0, path0) {
    var path0$1 = $$Array.to_list(path0);
    var _height = 0;
    var _acc = entry_hash;
    var _path = path0$1;
    while(true) {
      var path = _path;
      var acc = _acc;
      var height = _height;
      var b = ((addr0 >>> height) & 1) === 1;
      if (path) {
        var h = path[0];
        var l = b ? h : acc;
        var r = b ? acc : h;
        var acc$prime = merge(height, l, r);
        _path = path[1];
        _acc = acc$prime;
        _height = height + 1 | 0;
        continue ;
      } else {
        return acc;
      }
    };
  };
  var check = function (param, root, elt_hash) {
    return Curry._2(Hash.equal, implied_root(elt_hash, param[/* index */0], param[/* path */1]), root);
  };
  var MembershipProof = {
    ith_bit: ith_bit,
    path: path,
    create: create,
    implied_root: implied_root,
    check: check
  };
  var ceil_pow2 = function (x) {
    if (x <= 0) {
      Pervasives.failwith("ceil_pow2: negative");
    }
    var x$1 = x - 1 | 0;
    var x$2 = x$1 | (x$1 >>> 1);
    var x$3 = x$2 | (x$2 >>> 2);
    var x$4 = x$3 | (x$3 >>> 4);
    var x$5 = x$4 | (x$4 >>> 8);
    var x$6 = x$5 | (x$5 >>> 16);
    var x$7 = x$6 | (x$6 >>> 32);
    return x$7 + 1 | 0;
  };
  var ofArray = function (hash_element, $$default, leaves0) {
    var n = leaves0.length;
    var padding = ceil_pow2(n) - n | 0;
    var leaves = $$Array.append(leaves0, Caml_array.caml_make_vect(padding, $$default));
    var pair_up = function (arr, f) {
      return $$Array.init((arr.length >> 1), (function (i) {
                    return Curry._2(f, Caml_array.caml_array_get(arr, (i << 1)), Caml_array.caml_array_get(arr, (i << 1) + 1 | 0));
                  }));
    };
    var go = function (_height, _trees) {
      while(true) {
        var trees = _trees;
        var height = _height;
        if (trees.length === 1) {
          return /* tuple */[
                  Caml_array.caml_array_get(trees, 0),
                  height
                ];
        } else {
          var merged = pair_up(trees, (function(height){
              return function (l, r) {
                return /* Node */Block.__(1, [
                          merge(height, hash_tree(hash_element, l), hash_tree(hash_element, r)),
                          l,
                          r
                        ]);
              }
              }(height)));
          _trees = merged;
          _height = height + 1 | 0;
          continue ;
        }
      };
    };
    var match = go(0, $$Array.map((function (l) {
                return /* Element */Block.__(0, [l]);
              }), leaves));
    return /* record */[
            /* tree */match[0],
            /* hash_element */hash_element,
            /* depth */match[1]
          ];
  };
  return {
          Tree0: 0,
          Tree: Tree,
          hash_tree: hash_tree,
          root: root,
          depth: depth,
          merge: merge,
          MembershipProof: MembershipProof,
          ceil_pow2: ceil_pow2,
          ofArray: ofArray
        };
}

exports.Tree = Tree;
exports.Make = Make;
/* No side effect */
