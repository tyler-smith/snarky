// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

var $great = ((a, b) => a > b);

var $great$eq = ((a, b) => a >= b);

var $less = ((a, b) => a < b);

var $less$eq = ((a, b) => a <= b);

var zero = (BigInt(0));

var one = (BigInt(1));

var add = ((a, b) => a + b);

var sub = ((a, b) => a - b);

var mul = ((a, b) => a * b);

var div = ((a, b) => a / b);

var rem = ((a, b) => a % b);

var shiftLeft = ((a, b) => a << b);

var shiftRight = ((a, b) => a >> b);

var logAnd = ((a, b) => a & b);

var logOr = ((a, b) => a | b);

var ofString = ((s) => BigInt(s));

var ofInt = ((n) => BigInt(n));

function ofBits(bits) {
  var n = bits.length;
  var _acc = zero;
  var _i = 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i === n) {
      return acc;
    } else {
      var acc$1 = Caml_array.caml_array_get(bits, i) ? Curry._2(logOr, acc, Curry._2(shiftLeft, one, Curry._1(ofInt, i))) : acc;
      _i = i + 1 | 0;
      _acc = acc$1;
      continue ;
    }
  };
}

var toString = ((s) => s.toString());

var one$1 = Curry._1(ofInt, 1);

function testBit(t, i) {
  return Caml_obj.caml_equal(one$1, Curry._2(logAnd, one$1, Curry._2(shiftRight, t, Curry._1(ofInt, i))));
}

var $eq = ((a, b) => a === b);

var $$BigInt = {
  $great: $great,
  $great$eq: $great$eq,
  $less: $less,
  $less$eq: $less$eq,
  zero: zero,
  add: add,
  sub: sub,
  mul: mul,
  div: div,
  rem: rem,
  shiftLeft: shiftLeft,
  shiftRight: shiftRight,
  logAnd: logAnd,
  logOr: logOr,
  ofString: ofString,
  ofInt: ofInt,
  ofBits: ofBits,
  toString: toString,
  one: one$1,
  testBit: testBit,
  $plus: add,
  $neg: sub,
  $star: mul,
  $slash: div,
  $eq: $eq
};

function fieldSize(param) {
  return Curry._1(ofString, "21888242871839275222246405745257275088548364400416034343698204186575808495617");
}

function sizeInBits(param) {
  return 254;
}

var Params = {
  fieldSize: fieldSize,
  sizeInBits: sizeInBits
};

function Make0(C) {
  var size = C.size;
  var add$1 = function (x, y) {
    var z = Curry._2(add, x, y);
    if (Curry._2($great$eq, z, size)) {
      return Curry._2(sub, z, size);
    } else {
      return z;
    }
  };
  var sub$1 = function (x, y) {
    var z = Curry._2(sub, x, y);
    if (Curry._2($less, z, zero)) {
      return Curry._2(add, z, size);
    } else {
      return z;
    }
  };
  var mul$1 = function (x, y) {
    return Curry._2(rem, Curry._2(mul, x, y), size);
  };
  var invert = function (a) {
    var go = function (_t, _newt, _r, _newr) {
      while(true) {
        var newr = _newr;
        var r = _r;
        var newt = _newt;
        var t = _t;
        if (Curry._2($eq, newr, zero)) {
          return /* tuple */[
                  t,
                  r
                ];
        } else {
          var quotient = Curry._2(div, r, newr);
          _newr = Curry._2(sub, r, Curry._2(mul, quotient, newr));
          _r = newr;
          _newt = Curry._2(sub, t, Curry._2(mul, quotient, newt));
          _t = newt;
          continue ;
        }
      };
    };
    var match = go(zero, one$1, size, a);
    var t = match[0];
    if (Curry._2($great, match[1], one$1)) {
      return Pervasives.failwith("a is zero");
    } else if (Curry._2($less, t, zero)) {
      return Curry._2(add, t, size);
    } else {
      return t;
    }
  };
  var div$1 = function (x, y) {
    return mul$1(x, invert(y));
  };
  var negate = function (x) {
    if (Curry._2($eq, x, zero)) {
      return zero;
    } else {
      return Curry._2(sub, size, x);
    }
  };
  var ofString$1 = function (x) {
    return Curry._2(rem, Curry._1(ofString, x), size);
  };
  var ofBigInt = function (x) {
    return Curry._2(rem, x, size);
  };
  var square = function (x) {
    return mul$1(x, x);
  };
  return {
          size: size,
          toString: toString,
          add: add$1,
          sub: sub$1,
          mul: mul$1,
          invert: invert,
          inv: invert,
          equal: $eq,
          div: div$1,
          $plus: add$1,
          $neg: sub$1,
          $star: mul$1,
          $slash: div$1,
          one: one$1,
          zero: zero,
          negate: negate,
          ofString: ofString$1,
          ofInt: ofInt,
          ofBits: ofBits,
          ofBigInt: ofBigInt,
          square: square,
          testBit: testBit,
          $eq: $eq
        };
}

function Make(C) {
  C.curve;
  var size = Curry._1(ofString, "21888242871839275222246405745257275088548364400416034343698204186575808495617");
  var add$1 = function (x, y) {
    var z = Curry._2(add, x, y);
    if (Curry._2($great$eq, z, size)) {
      return Curry._2(sub, z, size);
    } else {
      return z;
    }
  };
  var sub$1 = function (x, y) {
    var z = Curry._2(sub, x, y);
    if (Curry._2($less, z, zero)) {
      return Curry._2(add, z, size);
    } else {
      return z;
    }
  };
  var mul$1 = function (x, y) {
    return Curry._2(rem, Curry._2(mul, x, y), size);
  };
  var invert = function (a) {
    var go = function (_t, _newt, _r, _newr) {
      while(true) {
        var newr = _newr;
        var r = _r;
        var newt = _newt;
        var t = _t;
        if (Curry._2($eq, newr, zero)) {
          return /* tuple */[
                  t,
                  r
                ];
        } else {
          var quotient = Curry._2(div, r, newr);
          _newr = Curry._2(sub, r, Curry._2(mul, quotient, newr));
          _r = newr;
          _newt = Curry._2(sub, t, Curry._2(mul, quotient, newt));
          _t = newt;
          continue ;
        }
      };
    };
    var match = go(zero, one$1, size, a);
    var t = match[0];
    if (Curry._2($great, match[1], one$1)) {
      return Pervasives.failwith("a is zero");
    } else if (Curry._2($less, t, zero)) {
      return Curry._2(add, t, size);
    } else {
      return t;
    }
  };
  var div$1 = function (x, y) {
    return mul$1(x, invert(y));
  };
  var negate = function (x) {
    if (Curry._2($eq, x, zero)) {
      return zero;
    } else {
      return Curry._2(sub, size, x);
    }
  };
  var ofString$1 = function (x) {
    return Curry._2(rem, Curry._1(ofString, x), size);
  };
  var ofBigInt = function (x) {
    return Curry._2(rem, x, size);
  };
  var square = function (x) {
    return mul$1(x, x);
  };
  return {
          size: size,
          toString: toString,
          add: add$1,
          sub: sub$1,
          mul: mul$1,
          invert: invert,
          inv: invert,
          equal: $eq,
          div: div$1,
          $plus: add$1,
          $neg: sub$1,
          $star: mul$1,
          $slash: div$1,
          one: one$1,
          zero: zero,
          negate: negate,
          ofString: ofString$1,
          ofInt: ofInt,
          ofBits: ofBits,
          ofBigInt: ofBigInt,
          square: square,
          testBit: testBit,
          $eq: $eq,
          sizeInBits: 254
        };
}

exports.$$BigInt = $$BigInt;
exports.Params = Params;
exports.Make0 = Make0;
exports.Make = Make;
/* > Not a pure module */
