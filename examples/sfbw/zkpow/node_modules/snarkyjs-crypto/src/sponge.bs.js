// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

var State = { };

function for_(n, init, f) {
  var _i = 0;
  var _acc = init;
  while(true) {
    var acc = _acc;
    var i = _i;
    if (i === n) {
      return acc;
    } else {
      _acc = Curry._2(f, i, acc);
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function Make_operations(Field) {
  var add_block = function (state, block) {
    return $$Array.iteri((function (i, bi) {
                  return Caml_array.caml_array_set(state, i, Curry._2(Field.$plus, Caml_array.caml_array_get(state, i), bi));
                }), block);
  };
  var reduce_exn = function (arr, f) {
    var n = arr.length;
    var _acc = Caml_array.caml_array_get(arr, 0);
    var _i = 1;
    while(true) {
      var i = _i;
      var acc = _acc;
      if (i === n) {
        return acc;
      } else {
        _i = i + 1 | 0;
        _acc = Curry._2(f, Caml_array.caml_array_get(arr, i), acc);
        continue ;
      }
    };
  };
  var map2 = function (f, xs, ys) {
    return $$Array.init(xs.length, (function (i) {
                  return Curry._2(f, Caml_array.caml_array_get(xs, i), Caml_array.caml_array_get(ys, i));
                }));
  };
  var apply_matrix = function (matrix, v) {
    var dotv = function (row) {
      return reduce_exn(map2(Field.$star, row, v), Field.$plus);
    };
    return $$Array.map(dotv, matrix);
  };
  return {
          add_block: add_block,
          reduce_exn: reduce_exn,
          map2: map2,
          apply_matrix: apply_matrix,
          copy: $$Array.copy
        };
}

function map_inplace(f, arr) {
  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(arr, i, Curry._1(f, Caml_array.caml_array_get(arr, i)));
  }
  return /* () */0;
}

function Rescue(Inputs) {
  var include = Inputs.Operations;
  var add_block = include.add_block;
  var apply_matrix = include.apply_matrix;
  var sbox0 = Inputs.alphath_root;
  var sbox1 = Inputs.to_the_alpha;
  var block_cipher = function (param, state) {
    var round_constants = param[/* round_constants */1];
    var mds = param[/* mds */0];
    Curry._2(add_block, state, Caml_array.caml_array_get(round_constants, 0));
    return for_((Inputs.rounds << 1), state, (function (r, state) {
                  var sbox = r % 2 === 0 ? sbox0 : sbox1;
                  map_inplace(sbox, state);
                  var state$1 = Curry._2(apply_matrix, mds, state);
                  Curry._2(add_block, state$1, Caml_array.caml_array_get(round_constants, r + 1 | 0));
                  return state$1;
                }));
  };
  return {
          add_block: add_block,
          apply_matrix: apply_matrix,
          copy: include.copy,
          Field: Inputs.Field,
          sbox0: sbox0,
          sbox1: sbox1,
          block_cipher: block_cipher
        };
}

function Poseidon(Inputs) {
  var include = Inputs.Operations;
  var add_block = include.add_block;
  var apply_matrix = include.apply_matrix;
  var half_rounds_full = Inputs.rounds_full / 2 | 0;
  var for_$1 = for_;
  var block_cipher = function (param, state) {
    var round_constants = param[/* round_constants */1];
    var mds = param[/* mds */0];
    var sbox = Inputs.to_the_alpha;
    var full_half = function (start) {
      var arg = function (r, state) {
        Curry._2(add_block, state, Caml_array.caml_array_get(round_constants, start + r | 0));
        map_inplace(sbox, state);
        return Curry._2(apply_matrix, mds, state);
      };
      return (function (param) {
          return for_(half_rounds_full, param, arg);
        });
    };
    var partial_arg = Inputs.rounds_partial;
    var arg = function (r, state) {
      Curry._2(add_block, state, Caml_array.caml_array_get(round_constants, half_rounds_full + r | 0));
      Caml_array.caml_array_set(state, 0, Curry._1(sbox, Caml_array.caml_array_get(state, 0)));
      return Curry._2(apply_matrix, mds, state);
    };
    return full_half(half_rounds_full + Inputs.rounds_partial | 0)((function (param) {
                    var param$1 = param;
                    var param$2 = arg;
                    return for_(partial_arg, param$1, param$2);
                  })(full_half(0)(state)));
  };
  return {
          add_block: add_block,
          apply_matrix: apply_matrix,
          copy: include.copy,
          Field: Inputs.Field,
          half_rounds_full: half_rounds_full,
          for_: for_$1,
          block_cipher: block_cipher
        };
}

function Make(P) {
  var sponge = function (perm, blocks, state) {
    return $$Array.fold_left((function (state, block) {
                  Curry._2(P.add_block, state, block);
                  return Curry._1(perm, state);
                }), state, blocks);
  };
  var to_blocks = function (r, a) {
    var n = a.length;
    return $$Array.init(Caml_int32.div((n + r | 0) - 1 | 0, r), (function (i) {
                  return $$Array.init(r, (function (j) {
                                var k = Caml_int32.imul(r, i) + j | 0;
                                if (k < n) {
                                  return Caml_array.caml_array_get(a, k);
                                } else {
                                  return P.Field.zero;
                                }
                              }));
                }));
  };
  var r = 2;
  var update = function (params, state, inputs) {
    var state$1 = Curry._1(P.copy, state);
    return sponge(Curry._1(P.block_cipher, params), to_blocks(r, inputs), state$1);
  };
  var digest = function (state) {
    return Caml_array.caml_array_get(state, 0);
  };
  var initial_state = $$Array.init(3, (function (param) {
          return P.Field.zero;
        }));
  var hash = function ($staropt$star, params, inputs) {
    var init = $staropt$star !== undefined ? $staropt$star : initial_state;
    return Caml_array.caml_array_get(update(params, init, inputs), 0);
  };
  return {
          sponge: sponge,
          to_blocks: to_blocks,
          r: r,
          update: update,
          digest: digest,
          initial_state: initial_state,
          hash: hash
        };
}

var Params = 0;

var Intf = 0;

var _rounds_for_alpha_equal_11 = 11;

var m = 3;

var _rounds_full_for_alpha_equal_11 = 8;

var _rounds_partial_for_alpha_equal_11 = 33;

exports.Params = Params;
exports.Intf = Intf;
exports.State = State;
exports.for_ = for_;
exports.Make_operations = Make_operations;
exports._rounds_for_alpha_equal_11 = _rounds_for_alpha_equal_11;
exports.m = m;
exports.map_inplace = map_inplace;
exports.Rescue = Rescue;
exports._rounds_full_for_alpha_equal_11 = _rounds_full_for_alpha_equal_11;
exports._rounds_partial_for_alpha_equal_11 = _rounds_partial_for_alpha_equal_11;
exports.Poseidon = Poseidon;
exports.Make = Make;
/* No side effect */
