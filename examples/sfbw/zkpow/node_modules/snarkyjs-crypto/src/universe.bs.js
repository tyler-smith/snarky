// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Field = require("./field.bs.js");
var Group = require("./group.bs.js");
var Params = require("./params.bs.js");
var Sponge = require("./sponge.bs.js");
var Signature = require("./signature.bs.js");
var Merkle_tree = require("./merkle_tree.bs.js");
var Sponge_params = require("./sponge_params.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function Make(C) {
  var Field$1 = Field.Make(C);
  var params = Params.map(Field$1.ofString, Sponge_params.Bn128.t);
  var to_the_alpha = function (x) {
    var x4 = Curry._1(Field$1.square, Curry._1(Field$1.square, x));
    return Curry._2(Field$1.$star, x, x4);
  };
  var Operations = Sponge.Make_operations({
        zero: Field$1.zero,
        $star: Field$1.$star,
        $plus: Field$1.$plus
      });
  var $$let = Sponge.Poseidon({
        Field: {
          zero: Field$1.zero
        },
        to_the_alpha: to_the_alpha,
        Operations: {
          add_block: Operations.add_block,
          apply_matrix: Operations.apply_matrix,
          copy: Operations.copy
        },
        rounds_full: 8,
        rounds_partial: 83
      });
  var include = Sponge.Make({
        Field: $$let.Field,
        add_block: $$let.add_block,
        copy: $$let.copy,
        block_cipher: $$let.block_cipher
      });
  var hash = Curry._2(include.hash, undefined, params);
  if (C.curve !== /* Bn128 */0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "universe.ml",
            40,
            11
          ]
        ];
  }
  var Group$1 = Group.BabyJubJub({
        equal: Field$1.equal,
        zero: Field$1.zero,
        one: Field$1.one,
        inv: Field$1.inv,
        $star: Field$1.$star,
        square: Field$1.square,
        negate: Field$1.negate,
        $neg: Field$1.$neg,
        $plus: Field$1.$plus,
        ofString: Field$1.ofString,
        toString: Field$1.toString
      });
  var is_even = function (t) {
    return !Field.$$BigInt.testBit(t, 0);
  };
  var $amp$amp = function (prim, prim$1) {
    if (prim) {
      return prim$1;
    } else {
      return false;
    }
  };
  var Bool = {
    $amp$amp: $amp$amp
  };
  var $$let$1 = Group$1.Scalar;
  var T = Signature.Make_signer({
        Bool: Bool,
        Field: {
          equal: Field$1.equal,
          size_in_bits: Field$1.sizeInBits,
          is_even: is_even
        },
        Scalar: {
          of_field: $$let$1.of_field,
          to_field: $$let$1.to_field,
          negate: $$let$1.negate,
          $plus: $$let$1.$plus,
          $star: $$let$1.$star
        },
        Group: {
          add_exn: Group$1.add_exn,
          to_affine_exn: Group$1.to_affine_exn,
          scale: Group$1.scale,
          one: Group$1.one,
          negate: Group$1.negate
        },
        Hash: {
          hash: hash
        }
      });
  var sign = T.sign;
  var check = T.check;
  var toJSON = function (param) {
    return /* array */[
            Curry._1(Field$1.toString, param[0]),
            Curry._1(Group$1.Scalar.toString, param[1])
          ];
  };
  var Signature$1 = {
    check: check,
    toJSON: toJSON
  };
  var ofPrivateKey = T.Public_key.of_private_key;
  var toJSON$1 = Group$1.toJSON;
  var PublicKey = {
    ofPrivateKey: ofPrivateKey,
    toJSON: toJSON$1
  };
  var bufferGet = ((b, i) => b[i]);
  (((global.crypto || (global.crypto = require('crypto')))));
  var randomBytes = ((x) => crypto.randomBytes(x));
  var create = function (param) {
    var arr = Curry._1(randomBytes, 31);
    var eight = Curry._1(Field.$$BigInt.ofInt, 8);
    var _acc = Curry._1(Field.$$BigInt.ofInt, 0);
    var _i = 0;
    while(true) {
      var i = _i;
      var acc = _acc;
      if (i === 31) {
        return acc;
      } else {
        var acc$1 = Curry._2(Field.$$BigInt.shiftLeft, acc, eight);
        _i = i + 1 | 0;
        _acc = Curry._2(Field.$$BigInt.logOr, acc$1, Curry._1(Field.$$BigInt.ofInt, Curry._2(bufferGet, arr, i)));
        continue ;
      }
    };
  };
  var toJSON$2 = function (t) {
    return Curry._1(Field.$$BigInt.toString, t);
  };
  var toString = function (t) {
    return Curry._1(Field.$$BigInt.toString, t);
  };
  var ofString = function (s) {
    return Curry._1(Field.$$BigInt.ofString, s);
  };
  var equal = Field$1.equal;
  var hash$1 = Curry.__1(hash);
  var MerkleTree = Merkle_tree.Make({
        equal: equal,
        hash: hash$1
      });
  var $$let$2 = MerkleTree.MembershipProof;
  return {
          Field: {
            $eq: Field$1.$eq,
            equal: Field$1.equal,
            $star: Field$1.$star,
            $plus: Field$1.$plus,
            $neg: Field$1.$neg,
            $slash: Field$1.$slash,
            mul: Field$1.mul,
            add: Field$1.add,
            sub: Field$1.sub,
            div: Field$1.div,
            negate: Field$1.negate,
            invert: Field$1.invert,
            square: Field$1.square,
            one: Field$1.one,
            zero: Field$1.zero,
            ofString: Field$1.ofString,
            ofInt: Field$1.ofInt,
            ofBits: Field$1.ofBits,
            toString: Field$1.toString,
            testBit: Field$1.testBit
          },
          Hash: {
            hash: hash
          },
          MerkleTree: {
            MembershipProof: {
              create: $$let$2.create,
              check: $$let$2.check
            },
            ofArray: MerkleTree.ofArray,
            root: MerkleTree.root,
            depth: MerkleTree.depth
          },
          Group: {
            toAffine: Group$1.toAffine,
            ofAffine: Group$1.ofAffine
          },
          Schnorr: {
            PrivateKey: {
              create: create,
              ofString: ofString,
              toString: toString,
              toJSON: toJSON$2
            },
            PublicKey: PublicKey,
            Signature: Signature$1,
            sign: sign
          }
        };
}

function make_obj(M) {
  var schnorr = {
    PrivateKey: {
      create: M.Schnorr.PrivateKey.create,
      toJSON: M.Schnorr.PrivateKey.toJSON
    },
    PublicKey: {
      ofPrivateKey: M.Schnorr.PublicKey.ofPrivateKey,
      toJSON: M.Schnorr.PublicKey.toJSON
    },
    Signature: {
      check: M.Schnorr.Signature.check,
      toJSON: M.Schnorr.Signature.toJSON
    },
    sign: M.Schnorr.sign
  };
  var field = {
    equal: M.Field.equal,
    add: M.Field.add,
    mul: M.Field.mul,
    sub: M.Field.sub,
    div: M.Field.div,
    ofInt: M.Field.ofInt,
    ofString: M.Field.ofString,
    toString: M.Field.toString,
    ofBits: M.Field.ofBits,
    testBit: M.Field.testBit,
    square: M.Field.square,
    invert: M.Field.invert,
    negate: M.Field.negate,
    zero: M.Field.zero,
    one: M.Field.one
  };
  var hash = {
    hash: M.Hash.hash
  };
  var of_obj = function (p) {
    return /* record */[
            /* index */p.index,
            /* path */p.path
          ];
  };
  var membership_proof = {
    create: (function (t, i) {
        var param = Curry._2(M.MerkleTree.MembershipProof.create, t, i);
        return {
                index: param[/* index */0],
                path: param[/* path */1]
              };
      }),
    check: (function (p, r, h) {
        return Curry._3(M.MerkleTree.MembershipProof.check, of_obj(p), r, h);
      })
  };
  var merkle_tree = {
    ofArray: M.MerkleTree.ofArray,
    depth: M.MerkleTree.depth,
    root: M.MerkleTree.root,
    MembershipProof: membership_proof
  };
  return {
          Field: field,
          Hash: hash,
          MerkleTree: merkle_tree,
          Schnorr: schnorr,
          Group: {
            toAffine: M.Group.toAffine
          }
        };
}

var C = {
  curve: /* Bn128 */0
};

var Field$1 = Field.Make(C);

var params = Params.map(Field$1.ofString, Sponge_params.Bn128.t);

function to_the_alpha(x) {
  var x4 = Curry._1(Field$1.square, Curry._1(Field$1.square, x));
  return Curry._2(Field$1.$star, x, x4);
}

var Operations = Sponge.Make_operations({
      zero: Field$1.zero,
      $star: Field$1.$star,
      $plus: Field$1.$plus
    });

var $$let = Sponge.Poseidon({
      Field: {
        zero: Field$1.zero
      },
      to_the_alpha: to_the_alpha,
      Operations: {
        add_block: Operations.add_block,
        apply_matrix: Operations.apply_matrix,
        copy: Operations.copy
      },
      rounds_full: 8,
      rounds_partial: 83
    });

var include = Sponge.Make({
      Field: $$let.Field,
      add_block: $$let.add_block,
      copy: $$let.copy,
      block_cipher: $$let.block_cipher
    });

var hash = Curry._2(include.hash, undefined, params);

var Group$1 = Group.BabyJubJub({
      equal: Field$1.equal,
      zero: Field$1.zero,
      one: Field$1.one,
      inv: Field$1.inv,
      $star: Field$1.$star,
      square: Field$1.square,
      negate: Field$1.negate,
      $neg: Field$1.$neg,
      $plus: Field$1.$plus,
      ofString: Field$1.ofString,
      toString: Field$1.toString
    });

function is_even(t) {
  return !Field.$$BigInt.testBit(t, 0);
}

function $amp$amp(prim, prim$1) {
  if (prim) {
    return prim$1;
  } else {
    return false;
  }
}

var Bool = {
  $amp$amp: $amp$amp
};

var $$let$1 = Group$1.Scalar;

var T = Signature.Make_signer({
      Bool: Bool,
      Field: {
        equal: Field$1.equal,
        size_in_bits: Field$1.sizeInBits,
        is_even: is_even
      },
      Scalar: {
        of_field: $$let$1.of_field,
        to_field: $$let$1.to_field,
        negate: $$let$1.negate,
        $plus: $$let$1.$plus,
        $star: $$let$1.$star
      },
      Group: {
        add_exn: Group$1.add_exn,
        to_affine_exn: Group$1.to_affine_exn,
        scale: Group$1.scale,
        one: Group$1.one,
        negate: Group$1.negate
      },
      Hash: {
        hash: hash
      }
    });

var sign = T.sign;

var check = T.check;

function toJSON(param) {
  return /* array */[
          Curry._1(Field$1.toString, param[0]),
          Curry._1(Group$1.Scalar.toString, param[1])
        ];
}

var Signature$1 = {
  check: check,
  toJSON: toJSON
};

var ofPrivateKey = T.Public_key.of_private_key;

var toJSON$1 = Group$1.toJSON;

var PublicKey = {
  ofPrivateKey: ofPrivateKey,
  toJSON: toJSON$1
};

var bufferGet = ((b, i) => b[i]);

(((global.crypto || (global.crypto = require('crypto')))));

var randomBytes = ((x) => crypto.randomBytes(x));

function create(param) {
  var arr = Curry._1(randomBytes, 31);
  var eight = Curry._1(Field.$$BigInt.ofInt, 8);
  var _acc = Curry._1(Field.$$BigInt.ofInt, 0);
  var _i = 0;
  while(true) {
    var i = _i;
    var acc = _acc;
    if (i === 31) {
      return acc;
    } else {
      var acc$1 = Curry._2(Field.$$BigInt.shiftLeft, acc, eight);
      _i = i + 1 | 0;
      _acc = Curry._2(Field.$$BigInt.logOr, acc$1, Curry._1(Field.$$BigInt.ofInt, Curry._2(bufferGet, arr, i)));
      continue ;
    }
  };
}

function toJSON$2(t) {
  return Curry._1(Field.$$BigInt.toString, t);
}

function toString(t) {
  return Curry._1(Field.$$BigInt.toString, t);
}

function ofString(s) {
  return Curry._1(Field.$$BigInt.ofString, s);
}

var equal = Field$1.equal;

var hash$1 = Curry.__1(hash);

var MerkleTree = Merkle_tree.Make({
      equal: equal,
      hash: hash$1
    });

var $$let$2 = MerkleTree.MembershipProof;

var Bn128_Field = {
  $eq: Field$1.$eq,
  equal: Field$1.equal,
  $star: Field$1.$star,
  $plus: Field$1.$plus,
  $neg: Field$1.$neg,
  $slash: Field$1.$slash,
  mul: Field$1.mul,
  add: Field$1.add,
  sub: Field$1.sub,
  div: Field$1.div,
  negate: Field$1.negate,
  invert: Field$1.invert,
  square: Field$1.square,
  one: Field$1.one,
  zero: Field$1.zero,
  ofString: Field$1.ofString,
  ofInt: Field$1.ofInt,
  ofBits: Field$1.ofBits,
  toString: Field$1.toString,
  testBit: Field$1.testBit
};

var Bn128_Hash = {
  hash: hash
};

var Bn128_MerkleTree = {
  MembershipProof: {
    create: $$let$2.create,
    check: $$let$2.check
  },
  ofArray: MerkleTree.ofArray,
  root: MerkleTree.root,
  depth: MerkleTree.depth
};

var Bn128_Group = {
  toAffine: Group$1.toAffine,
  ofAffine: Group$1.ofAffine
};

var Bn128_Schnorr = {
  PrivateKey: {
    create: create,
    ofString: ofString,
    toString: toString,
    toJSON: toJSON$2
  },
  PublicKey: PublicKey,
  Signature: Signature$1,
  sign: sign
};

var Bn128 = {
  Field: Bn128_Field,
  Hash: Bn128_Hash,
  MerkleTree: Bn128_MerkleTree,
  Group: Bn128_Group,
  Schnorr: Bn128_Schnorr
};

var bn128 = make_obj(Bn128);

var Field0 = 0;

exports.Field0 = Field0;
exports.Make = Make;
exports.make_obj = make_obj;
exports.Bn128 = Bn128;
exports.bn128 = bn128;
/* Field Not a pure module */
